//@author: a0101252a



	/**
	 * origin: C:\Users\Sai Hou\Documents\SAIHOU\CS2103T\cs2103jan2014-w13-4j\src\ActionHistory.java
	 */

import java.util.ArrayDeque;
 
/*
 *	This class stores the history of the last user action in a stack.
 *	It will be referred to by the undo function in the CommandExecutor class.
 */

public class ActionHistory<E> {
	
	private ArrayDeque<E> historyOfCommands;
	
	public ActionHistory() {
		historyOfCommands = new ArrayDeque<E>();
	}
	
	public void push(E command) {
		historyOfCommands.push(command);
	}
	
	public E pop() {
		return historyOfCommands.pop();
	}
	
	public E peek() {
		return historyOfCommands.peek();
	}
	
	public boolean isEmpty() {
		return historyOfCommands.isEmpty();
	}
	
	// End of segment: C:\Users\Sai Hou\Documents\SAIHOU\CS2103T\cs2103jan2014-w13-4j\src\ActionHistory.java





	/**
	 * origin: C:\Users\Sai Hou\Documents\SAIHOU\CS2103T\cs2103jan2014-w13-4j\src\CommandExecutorTest.java
	 */


/*
 *	This class contains the jUnit tests for CommandExecutor and ActionHistory Class. It checks if:
 *	1. The Add (all Types of Tasks), Display, Edit, Delete, Undo and Clear are working correctly.
 *	2. The action history has been updated correctly after each action (if applicable).
 * 	
 */
import static org.junit.Assert.*;

import java.text.SimpleDateFormat;
import java.util.ArrayDeque;
import java.util.Calendar;
import java.util.Queue;

import org.junit.Test;

public class CommandExecutorTest {
	/* Date formatters */
	private static SimpleDateFormat inputDateFormat = new SimpleDateFormat("ddMMyy");
	private static SimpleDateFormat displayDateFormat = new SimpleDateFormat("dd-MMM-yyyy <EEE>");
	
	/* Display headings */
	private static final String HEADING_MEMOS = "Memos:\n";
	private static final String HEADING_TASKS_OCCURRING_DUE_MORE_THAN_A_WEEK_LATER = "Tasks Occurring/Due More Than A Week Later:\n";
	private static final String HEADING_TASKS_OCCURRING_DUE_WITHIN_7_DAYS = "Tasks Occurring/Due Within 7 Days:\n";
	private static final String HEADING_TODAY_S_TASKS = "Today's Tasks:\n";
	private static final String HEADING_OVERDUE_TASKS = "Overdue Tasks:\n";
	
	/* Static Feedbacks */
	private static String FEEDBACK_CLEAR_ALL = "Successfully cleared all tasks.";
	
	/* Pre-defined spacing for formatting purposes */
	private static final String TASK_NUMBER_SPACING = "   ";
	private static final String DETAILS_SPACING = "      ";
	
	@Test
	public void test() {
		CommandExecutor exec = new CommandExecutor();
		
		positiveTestForDoUserOperations(exec);
	}
	
	/*
	 * A series of tests that test the CommandExecutor.doUserOperation method.
	 * They test the validity of the returned Result in particular.
	 */
	private void positiveTestForDoUserOperations(CommandExecutor exec) {
		//Chain of tests testing basic functions: clear, add, display, 
		// edit, delete, undo delete, undo edit and undo add
		assertDoClearOperation(exec);
		assertDoAddOverdueOperation(exec);
		assertDoDefaultDisplayOperation(exec);
		assertDoEditOperation(exec);
		assertDoDeleteOperation(exec);
		assertDoUndoDeleteOperation(exec);
		assertDoUndoEditOperation(exec);
		assertDoUndoAddOperation(exec);
		
		//Clear any tasks just in case
		assertDoClearOperation(exec);
		
		//Ensure Result is valid when more than 1 task exists, test includes
		//adding different tasks that fall under all display headings
		assertDoAddOperationsForAllHeadings(exec);
	}

	private void assertDoClearOperation(CommandExecutor exec) {
		int indexI = -1;
		int indexJ = -1;
		String feedback = FEEDBACK_CLEAR_ALL;
		ArrayDeque<String> headings = new ArrayDeque<String>(); 
		ArrayDeque<Queue<String>> bodyAll = new ArrayDeque<Queue<String>>();
		
		Result expectedResults = new Result(indexI, indexJ, feedback, headings, bodyAll, true);
		Result actualResults = exec.doUserOperation("clear all");
		
		assertEquals("Do Clear Operation", expectedResults, actualResults);
	}	
	
	private Result assertDoAddOverdueOperation(CommandExecutor exec) {
		int indexI = 0;
		int indexJ = 0;
		String feedback = "Successfully added \"An overdue task\".";
		ArrayDeque<String> headings = new ArrayDeque<String>(); 
		headings.offer(HEADING_OVERDUE_TASKS);
		
		Queue<String> bodySegment = new ArrayDeque<String>();
		bodySegment.offer(TASK_NUMBER_SPACING + "1. An overdue task\n" + 
						DETAILS_SPACING + "01-Jan-2014 <Wed>\n" +
						DETAILS_SPACING + "From 12:00 to 13:00\n");
		
		ArrayDeque<Queue<String>> bodyAll = new ArrayDeque<Queue<String>>();
		bodyAll.offer(bodySegment);
		
		Result expectedResults = new Result(indexI, indexJ, feedback, headings, bodyAll, true);
		Result actualResults = exec.doUserOperation("add an overdue task /on 010114 /from 1200 to 1300");
		
		assertEquals("Do Add Overdue Operation", expectedResults, actualResults);
		
		return expectedResults;
	}
	
	private void assertDoEditOperation(CommandExecutor exec) {
		int indexI = 0;
		int indexJ = 0;
		String feedback = "Successfully made changes to \"An overdue task\".";
		ArrayDeque<String> headings = new ArrayDeque<String>(); 
		headings.offer(HEADING_OVERDUE_TASKS);
		
		Queue<String> bodySegment = new ArrayDeque<String>();
		bodySegment.offer(TASK_NUMBER_SPACING + "1. An overdue task\n" + 
						DETAILS_SPACING + "02-Jan-2014 <Thu>\n" +
						DETAILS_SPACING + "From 12:00 to 13:00\n");
		
		ArrayDeque<Queue<String>> bodyAll = new ArrayDeque<Queue<String>>();
		bodyAll.offer(bodySegment);
		
		Result expectedResults = new Result(indexI, indexJ, feedback, headings, bodyAll, true);
		Result actualResults = exec.doUserOperation("edit 1 /on 020114 /from 1200 to 1300");
		
		assertEquals("Do Edit Operation", expectedResults, actualResults);
	}
	
	private void assertDoDeleteOperation(CommandExecutor exec) {
		int indexI = -1;
		int indexJ = -1;
		String feedback = "Successfully deleted 1. An overdue task.";

		ArrayDeque<String> headings = new ArrayDeque<String>(); 
		ArrayDeque<Queue<String>> bodyAll = new ArrayDeque<Queue<String>>();
		
		Result expectedResults = new Result(indexI, indexJ, feedback, headings, bodyAll, true);
		Result actualResults = exec.doUserOperation("del 1");

		assertEquals("Do Delete Operation", expectedResults, actualResults);
	}
	
	private void assertDoUndoDeleteOperation(CommandExecutor exec) {
		int indexI = 0;
		int indexJ = 0;
		String feedback = "Undo previous deletion: Successfully added \"An overdue task\".";
		ArrayDeque<String> headings = new ArrayDeque<String>(); 
		headings.offer(HEADING_OVERDUE_TASKS);
		
		Queue<String> bodySegment = new ArrayDeque<String>();
		bodySegment.offer(TASK_NUMBER_SPACING + "1. An overdue task\n" + 
						DETAILS_SPACING + "02-Jan-2014 <Thu>\n" +
						DETAILS_SPACING + "From 12:00 to 13:00\n");
		
		ArrayDeque<Queue<String>> bodyAll = new ArrayDeque<Queue<String>>();
		bodyAll.offer(bodySegment);
		
		Result expectedResults = new Result(indexI, indexJ, feedback, headings, bodyAll, true);
		Result actualResults = exec.doUserOperation("undo");
		assertEquals("Do Undo Delete Operation", expectedResults, actualResults);
	}
	
	private void assertDoUndoEditOperation(CommandExecutor exec) {
		int indexI = 0;
		int indexJ = 0;
		String feedback = "Undo previous update: Successfully reverted \"An overdue task\".";
		ArrayDeque<String> headings = new ArrayDeque<String>(); 
		headings.offer(HEADING_OVERDUE_TASKS);
		
		Queue<String> bodySegment = new ArrayDeque<String>();
		bodySegment.offer(TASK_NUMBER_SPACING + "1. An overdue task\n" + 
						DETAILS_SPACING + "01-Jan-2014 <Wed>\n" +
						DETAILS_SPACING + "From 12:00 to 13:00\n");
		
		ArrayDeque<Queue<String>> bodyAll = new ArrayDeque<Queue<String>>();
		bodyAll.offer(bodySegment);
		
		Result expectedResults = new Result(indexI, indexJ, feedback, headings, bodyAll, true);
		Result actualResults = exec.doUserOperation("undo");
		assertEquals("Do Undo Edit Operation", expectedResults, actualResults);
	}
	
	private void assertDoUndoAddOperation(CommandExecutor exec) {
		int indexI = -1;
		int indexJ = -1;
		String feedback = "Undo previous addition: Successfully deleted \"An overdue task\".";
		ArrayDeque<String> headings = new ArrayDeque<String>(); 
		ArrayDeque<Queue<String>> bodyAll = new ArrayDeque<Queue<String>>();
		
		Result expectedResults = new Result(indexI, indexJ, feedback, headings, bodyAll, true);
		Result actualResults = exec.doUserOperation("undo");
		
		assertEquals("Do Undo Add Operation", expectedResults, actualResults);
	}
	
	private void assertDoDefaultDisplayOperation(CommandExecutor exec) {
		int indexI = -1;
		int indexJ = -1;
		String feedback = "Displaying uncompleted tasks.";
		ArrayDeque<String> headings = new ArrayDeque<String>(); 
		headings.offer(HEADING_OVERDUE_TASKS);
		
		Queue<String> bodySegment = new ArrayDeque<String>();
		bodySegment.offer(TASK_NUMBER_SPACING + "1. An overdue task\n" + 
						DETAILS_SPACING + "01-Jan-2014 <Wed>\n" +
						DETAILS_SPACING + "From 12:00 to 13:00\n");
		
		ArrayDeque<Queue<String>> bodyAll = new ArrayDeque<Queue<String>>();
		bodyAll.offer(bodySegment);
		
		Result expectedResults = new Result(indexI, indexJ, feedback, headings, bodyAll, true);
		Result actualResults = exec.doUserOperation("display");
		assertEquals("Do Display Operation", expectedResults, actualResults);
	}
	
	
	
	private void assertDoAddOperationsForAllHeadings(CommandExecutor exec) {
		assertDoAddOverdueOperation(exec);
		assertDoAddTodayOperation(exec);
		assertDoAddThisWeekOperation(exec);
		assertDoAddNextWeekOperation(exec);
		assertDoAddMemoOperation(exec);
	}
	
	private void addOverdueBodySegment(ArrayDeque<Queue<String>> bodyAll){
		Queue<String> bodySegment = new ArrayDeque<String>();
		bodySegment.offer(TASK_NUMBER_SPACING + "1. An overdue task\n" + 
						DETAILS_SPACING + "01-Jan-2014 <Wed>\n" +
						DETAILS_SPACING + "From 12:00 to 13:00\n");
		bodyAll.offer(bodySegment);
	}
	
	private void addTodayBodySegment(ArrayDeque<Queue<String>> bodyAll, Calendar date) {
		Queue<String> bodySegment = new ArrayDeque<String>();
		bodySegment.offer(TASK_NUMBER_SPACING + "2. A task for today\n" + 
						DETAILS_SPACING + displayDateFormat.format(date.getTime()) + "\n");
		bodyAll.offer(bodySegment);
	}
	
	private void addThisWeekBodySegment(ArrayDeque<Queue<String>> bodyAll, Calendar date) {
		date.add(Calendar.DATE, 6);  
		Queue<String> bodySegment = new ArrayDeque<String>();
		bodySegment.offer(TASK_NUMBER_SPACING + "3. A task for the week\n" + 
						DETAILS_SPACING + displayDateFormat.format(date.getTime()) + "\n");
		bodyAll.offer(bodySegment);
	}
	
	private void addNextWeekBodySegment(ArrayDeque<Queue<String>> bodyAll, Calendar date) {
		date.add(Calendar.DATE, 7);
		Queue<String> bodySegment = new ArrayDeque<String>();
		bodySegment.offer(TASK_NUMBER_SPACING + "4. A task for the next week\n" + 
						DETAILS_SPACING + displayDateFormat.format(date.getTime()) + "\n");
		bodyAll.offer(bodySegment);
	}
	
	private void addMemosBodySegment(ArrayDeque<Queue<String>> bodyAll) {
		Queue<String> bodySegment = new ArrayDeque<String>();
		bodySegment.offer(TASK_NUMBER_SPACING + "1. A memo\n");
		bodySegment.offer(TASK_NUMBER_SPACING + "2. A second memo\n");
		bodyAll.offer(bodySegment);
	}
	
	private void assertDoAddTodayOperation(CommandExecutor exec) {	
		Calendar todaysDate = Calendar.getInstance();
		
		String feedback = "Successfully added \"A task for today\".";
		
		ArrayDeque<String> headings = new ArrayDeque<String>(); 
		headings.offer(HEADING_OVERDUE_TASKS);
		headings.offer(HEADING_TODAY_S_TASKS);
		
		ArrayDeque<Queue<String>> bodyAll = new ArrayDeque<Queue<String>>();
		addOverdueBodySegment(bodyAll);
		addTodayBodySegment(bodyAll, todaysDate);
		
		Result expectedResults = new Result(1, 0, feedback, headings, bodyAll, true);
		Result actualResults = exec.doUserOperation("add a task for today /on " + 
								inputDateFormat.format(todaysDate.getTime()));
		
		assertEquals("Do Add Today Operation", expectedResults, actualResults);
	}
	
	private void assertDoAddThisWeekOperation(CommandExecutor exec) {
		Calendar todaysDate = Calendar.getInstance();
		
		String feedback = "Successfully added \"A task for the week\".";
		
		ArrayDeque<String> headings = new ArrayDeque<String>(); 
		headings.offer(HEADING_OVERDUE_TASKS);
		headings.offer(HEADING_TODAY_S_TASKS);
		headings.offer(HEADING_TASKS_OCCURRING_DUE_WITHIN_7_DAYS);
		
		ArrayDeque<Queue<String>> bodyAll = new ArrayDeque<Queue<String>>();
		addOverdueBodySegment(bodyAll);
		addTodayBodySegment(bodyAll, (Calendar)todaysDate.clone());
		addThisWeekBodySegment(bodyAll, (Calendar)todaysDate.clone());
		
		Result expectedResults = new Result(2, 0, feedback, headings, bodyAll, true);
		
		todaysDate.add(Calendar.DATE, 6);  
		Result actualResults = exec.doUserOperation("add a task for the week /on " + 
								inputDateFormat.format(todaysDate.getTime()));
		
		assertEquals("Do Add Task In This Week Operation", expectedResults, actualResults);
	}
	
	private void assertDoAddNextWeekOperation(CommandExecutor exec) {		
		Calendar todaysDate = Calendar.getInstance();
		
		String feedback = "Successfully added \"A task for the next week\".";
		
		ArrayDeque<String> headings = new ArrayDeque<String>(); 
		headings.offer(HEADING_OVERDUE_TASKS);
		headings.offer(HEADING_TODAY_S_TASKS);
		headings.offer(HEADING_TASKS_OCCURRING_DUE_WITHIN_7_DAYS);
		headings.offer(HEADING_TASKS_OCCURRING_DUE_MORE_THAN_A_WEEK_LATER);
		
		ArrayDeque<Queue<String>> bodyAll = new ArrayDeque<Queue<String>>();
		addOverdueBodySegment(bodyAll);
		addTodayBodySegment(bodyAll, (Calendar)todaysDate.clone());
		addThisWeekBodySegment(bodyAll, (Calendar)todaysDate.clone());
		addNextWeekBodySegment(bodyAll, (Calendar)todaysDate.clone());
		
		Result expectedResults = new Result(3, 0, feedback, headings, bodyAll, true);
		
		todaysDate.add(Calendar.DATE, 7); 
		Result actualResults = exec.doUserOperation("add a task for the next week /on " + 
								inputDateFormat.format(todaysDate.getTime()));
		
		assertEquals("Do Add Task In The Next Week Operation", expectedResults, actualResults);
	}
	
	private void assertDoAddMemoOperation(CommandExecutor exec) {
		Calendar todaysDate = Calendar.getInstance();
		
		String feedback = "Successfully added \"A second memo\".";
		
		ArrayDeque<String> headings = new ArrayDeque<String>(); 
		headings.offer(HEADING_OVERDUE_TASKS);
		headings.offer(HEADING_TODAY_S_TASKS);
		headings.offer(HEADING_TASKS_OCCURRING_DUE_WITHIN_7_DAYS);
		headings.offer(HEADING_TASKS_OCCURRING_DUE_MORE_THAN_A_WEEK_LATER);
		headings.offer(HEADING_MEMOS);
		
		ArrayDeque<Queue<String>> bodyAll = new ArrayDeque<Queue<String>>();
		addOverdueBodySegment(bodyAll);
		addTodayBodySegment(bodyAll, (Calendar)todaysDate.clone());
		addThisWeekBodySegment(bodyAll, (Calendar)todaysDate.clone());
		addNextWeekBodySegment(bodyAll, (Calendar)todaysDate.clone());
		addMemosBodySegment(bodyAll);
		
		Result expectedResults = new Result(4, 1, feedback, headings, bodyAll, true);
		exec.doUserOperation("add a memo");
		Result actualResults = exec.doUserOperation("add a second memo");
		
		assertEquals("Do Add A Second Memo Operation", expectedResults, actualResults);
	}
}

	// End of segment: C:\Users\Sai Hou\Documents\SAIHOU\CS2103T\cs2103jan2014-w13-4j\src\CommandExecutorTest.java





	/**
	 * origin: C:\Users\Sai Hou\Documents\SAIHOU\CS2103T\cs2103jan2014-w13-4j\src\DateTimeConfiguration.java
	 */

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.concurrent.TimeUnit;

/*
 * This class handles all date and time related formatting and 
 * any complicated comparisons between dates and time.
 */
public class DateTimeConfiguration {
	/* Format of dates */
	private static final String DISPLAY_DATE_FORMAT = "dd-MMM-yyyy <EEE>";
	private static final String SYSTEM_DATE_FORMAT = "ddMMyy";
	
	/* SimpleDateFormat instances used to format date */
	private SimpleDateFormat systemDateFormat;
	private SimpleDateFormat displayDateFormat;
	
	/* Constructor */
	public DateTimeConfiguration() {
		systemDateFormat = new SimpleDateFormat(SYSTEM_DATE_FORMAT);
		displayDateFormat = new SimpleDateFormat(DISPLAY_DATE_FORMAT);
	}
	
	/*
	 * @return	Today's date in DDMMYY format as stored in system
	 */
	public String getTodaysDate() {
		Calendar date = Calendar.getInstance();
		return systemDateFormat.format(date.getTime());
	}

	/*
	 * @param	time	Time in HHMM format as stored in system
	 * @return			time in HH:MM format
	 */
	public String getTimeForDisplay(String time) {
		return time.substring(0,2) + ':' + time.substring(2);
	}
	
	/*
	 * @param 	dateToFormat	Date in DDMMYY format as stored in system
	 * @return 					date in DD-MMM-YYYY format for display
	 */
	public String getDateForDisplay(String dateToFormat) {
		Date date = null;
		try {
			date = systemDateFormat.parse(dateToFormat);
		} catch (ParseException e) {
			e.printStackTrace();
		}
		return displayDateFormat.format(date);
	}
	
	/*
	 * Checks if taskDate is in the past or today.
	 */
	public boolean isPastOrToday(String taskDate, String todaysDate) {
		long differenceInDays = getDifferenceInDays(taskDate, todaysDate);
		
		if (differenceInDays <= 0) {
			return true;
		}
		return false;
	}
	
	/*
	 * Checks if taskDate is within 7 days from today and not today.
	 * (exclusive of 7th day)
	 */
	public boolean isThisWeekButNotToday(String taskDate, String todaysDate) {
		long differenceInDays = getDifferenceInDays(taskDate, todaysDate);
		
		if (differenceInDays > 0 && differenceInDays < 7) {
			return true;
		}
		return false;
	}
	
	/*
	 * Checks if taskDate is 7 or more days after today's date.
	 */
	public boolean isAfterAWeek(String taskDate, String todaysDate) {
		long differenceInDays = getDifferenceInDays(taskDate, todaysDate);
		
		if (differenceInDays >= 7) {
			return true;
		}
		return false;
	}
	
	/*
	 * Gets the difference in days between taskD and todaysD.
	 */
	private long getDifferenceInDays(String taskD, String todaysD) {
		Date taskDate = null;
		Date todaysDate = null;
		try {
			taskDate = systemDateFormat.parse(taskD);
			todaysDate = systemDateFormat.parse(todaysD);
		} catch (ParseException e) {
			e.printStackTrace();
		}
		
		long differenceInMilliseconds = taskDate.getTime() - todaysDate.getTime();
		long differenceInDays = TimeUnit.MILLISECONDS.toDays(differenceInMilliseconds); 
		
		return differenceInDays;
	}

	/* 
	 * Reverse specified date String from DDMMYY to YYMMDD format to directly compare values  
	 * using pre-defined compareTo function in Java String class.
	 */
	public String reverseDate(String originalDate) {
		String reversedDate = "";
		for (int i = 6; i > 0; i -= 2){
			String toAppend = originalDate.substring(i-2, i);
			reversedDate += toAppend;
		}
		return reversedDate;
	}
	
}

	// End of segment: C:\Users\Sai Hou\Documents\SAIHOU\CS2103T\cs2103jan2014-w13-4j\src\DateTimeConfiguration.java





	/**
	 * origin: C:\Users\Sai Hou\Documents\SAIHOU\CS2103T\cs2103jan2014-w13-4j\src\DateTimeConfigurationTest.java
	 */

import static org.junit.Assert.*;
import org.junit.Test;

/*
 * This class contains unit tests for DateTimeConfiguration class.
 */
public class DateTimeConfigurationTest {

	@Test
	public void test() {
		DateTimeConfiguration dateTimeConfig = new DateTimeConfiguration();
		
		assertDateForDisplay(dateTimeConfig);
		assertTimeForDisplay(dateTimeConfig);
		assertIsPastOrToday(dateTimeConfig);
		assertIsThisWeekButNotToday(dateTimeConfig);
		assertIsAfterAWeek(dateTimeConfig);
		assertReverseDate(dateTimeConfig);
	}
	
	private void assertDateForDisplay(DateTimeConfiguration dateTimeConfig) {
		assertEquals("Date for Display should be dd-mmm-yyyy", 
				"23-May-2014 <Fri>", dateTimeConfig.getDateForDisplay("230514"));
		assertNotEquals("False test: Date for Display different dates test", 
				"23-May-2014 <Fri>", dateTimeConfig.getDateForDisplay("121212"));
	}
	
	private void assertTimeForDisplay(DateTimeConfiguration dateTimeConfig) {
		assertEquals("Time for Display should be hh:mm", 
				"00:00", dateTimeConfig.getTimeForDisplay("0000"));
		assertNotEquals("False test: Time for Display different times test",
				"00:00", dateTimeConfig.getTimeForDisplay("1111"));
	}
	
	private void assertIsPastOrToday(DateTimeConfiguration dateTimeConfig) {
		assertEquals("Date is in the past", 
				true, dateTimeConfig.isPastOrToday("010114", "020114"));
		assertEquals("Date is same as today",
				true, dateTimeConfig.isPastOrToday("010114", "010114"));
		assertEquals("Past/Today test: Date is not in the past/today", 
				false, dateTimeConfig.isPastOrToday("020114", "010114"));
	}
	
	private void assertIsThisWeekButNotToday(DateTimeConfiguration dateTimeConfig) {
		assertEquals("Date is this week but not today", 
				true, dateTimeConfig.isThisWeekButNotToday("180414", "120414"));
		assertEquals("This week/not today test: Date is in the future",
				false, dateTimeConfig.isThisWeekButNotToday("190414", "120414"));
		assertEquals("This week/not today test: Date is in the past",
				false, dateTimeConfig.isThisWeekButNotToday("010414", "120414"));
	}
	
	private void assertIsAfterAWeek(DateTimeConfiguration dateTimeConfig) {
		assertEquals("Date is immediately after a week", 
				true, dateTimeConfig.isAfterAWeek("080114", "010114"));
		assertEquals("Is after a week test: Date is on the 7th day after today", 
				false, dateTimeConfig.isAfterAWeek("070114", "010114"));
		assertEquals("Is after a week test: Date is in the past", 
				false, dateTimeConfig.isAfterAWeek("010114", "050414"));
	}
	
	private void assertReverseDate(DateTimeConfiguration dateTimeConfig) {
		assertEquals("Reverse Date: symmetrical test", 
				"140514", dateTimeConfig.reverseDate("140514"));
		assertEquals("Reverse Date: normal test", 
				"140311", dateTimeConfig.reverseDate("110314"));
	}

}

	// End of segment: C:\Users\Sai Hou\Documents\SAIHOU\CS2103T\cs2103jan2014-w13-4j\src\DateTimeConfigurationTest.java





	/**
	 * origin: C:\Users\Sai Hou\Documents\SAIHOU\CS2103T\cs2103jan2014-w13-4j\src\DisplayCommand.java
	 */

import java.util.ArrayList;
import java.util.Collections;

/*
* Command pattern: This is one of the concrete commands.
* 
* Description: This class will handle the display operations.
* Display operations include display (default: undone tasks), all, overdue,
* today, done, undone, memos.
*/
public class DisplayCommand extends Command {

	/* Instances of other classes used: Parser for parsing, 
	 * dateTimeConfig for getting date/time information, and 
	 * taskToHighlight to process tasks. */
	protected CommandParser parser;
	protected DateTimeConfiguration dateTimeConfig;
	
	protected Task taskToHighlight;
	
	/* Error messages */ 
	private final static String MESSAGE_INVALID_COMMAND = "ERROR: Invalid command entered. Please try again.";
	
	/* Headings for displaying tasks */ 
	private final static String HEADING_OVERDUE = "Overdue Tasks:\n";
	private final static String HEADING_TODAY = "Today's Tasks:\n"; 
	private final static String HEADING_THIS_WEEK = "Tasks Occurring/Due Within 7 Days:\n";
	private final static String HEADING_AFTER_A_WEEK = "Tasks Occurring/Due More Than A Week Later:\n";
	private final static String HEADING_MEMO = "Memos:\n";
	private final static String HEADING_COMPLETED = "Completed Tasks:\n";
	
	/* Feedback when there are no tasks in manager */
	private final static String FEEDBACK_NO_OVERDUE = "You have no overdue tasks.";
	private final static String FEEDBACK_NO_TODAY = "You have no tasks for today.";
	private final static String FEEDBACK_NO_DONE = "You have no completed tasks.";
	private final static String FEEDBACK_NO_UNDONE = "You have no uncompleted tasks.";
	private final static String FEEDBACK_NO_MEMOS = "You have no memos.";
	private final static String FEEDBACK_NO_TASKS = "You have no tasks.";
	
	/* Feedback for various displays when there are existing tasks */ 
	private final static String FEEDBACK_DISPLAY_ALL = "Displaying all tasks.";
	private final static String FEEDBACK_DISPLAY_OVERDUE = "Displaying overdue tasks.";
	private final static String FEEDBACK_DISPLAY_TODAY = "Displaying tasks for today.";
	private final static String FEEDBACK_DISPLAY_DONE = "Displaying completed tasks.";
	private final static String FEEDBACK_DISPLAY_UNDONE = "Displaying uncompleted tasks.";
	private final static String FEEDBACK_DISPLAY_MEMOS = "Displaying memos.";

	/* Pre-defined spacing for formatting purposes */
	private final static String TASK_NUMBER_SPACING = "   ";
	
	/* For identifying display type */
	private final static String ALL = "all";
	private final static String OVERDUE = "overdue";
	private final static String TODAY = "today";
	private final static String DONE = "done";
	private final static String UNDONE = "undone";
	private final static String MEMOS = "memos";
	
	public DisplayCommand() {
		super();
		dateTimeConfig = new DateTimeConfiguration();
	}
	
	/*
	 * Calls execute display command.
	 * @see Command#execute(java.lang.String)
	 */
	@Override
	public void execute(String userCommand) {
		parser = new CommandParser();
		executeDisplayCommand(userCommand);
		result.setSystemFeedback(systemFeedback);
	}
	
	/*
	 * Executes display command by setting currentTaskList to the list of task
	 * that matches the display required, forming the display result and also
	 * setting the systemFeedback.
	 * 
	 * @param userCommand A valid command input from user
	 */
	public void executeDisplayCommand(String userCommand) {
		systemFeedback = "";
		if (allTasks.isEmpty()) {
			systemFeedback = FEEDBACK_NO_TASKS;
		} else {
			String displayType = parser.parseDisplayType(userCommand);
			assert(displayType != null);
			
			try {
				prepareCurrentTaskList(displayType);
				
				if (currentTaskList.isEmpty()) {
					systemFeedback = getFeedbackIfHaveNoTasks(displayType);
				}

				if (systemFeedback.equals("")) {
					formDisplayText(result);
					systemFeedback = getFeedbackIfHaveTasks(displayType);
				}
			} catch (Exception ex) {
				System.out.println(ex.getMessage());
				systemFeedback = ex.getMessage();
			} 
		}
	}

	/* 
	 * Sorts the entire task list and sets currentTaskList to a list of tasks that 
	 * contains only the tasks required for display, based on displayType.
	 * 
	 * @param	displayType		Type of display requested by user (e.g. all, overdue, today etc.)
	 * @return 					true if task list is successfully set
	 * @throws	IllegalArgumentException If displayType is not recognized
	 */
	private boolean prepareCurrentTaskList(String displayType) throws IllegalArgumentException {
		Collections.sort(allTasks);

		//Set currentTaskList to default: all undone tasks
		boolean isDone = false;
		currentTaskList = getTasksBasedOnCompletion(allTasks, isDone);

		switch (displayType) {
			case ALL : 
				//Append completed tasks at the end of list
				isDone = true;
				ArrayList<Task> completedTasks = getTasksBasedOnCompletion(allTasks, isDone);
				currentTaskList.addAll(completedTasks);
				break;
			case OVERDUE :
				currentTaskList = getOverdue(currentTaskList);
				break;
			case MEMOS :
				currentTaskList = getMemos(currentTaskList);
				break;
			case TODAY :
				currentTaskList = getTodaysTasks();
				break;
			case UNDONE :
				break;
			case DONE :
				isDone = true;
				currentTaskList = getTasksBasedOnCompletion(allTasks, isDone);
				break;
			default :
				throw new IllegalArgumentException(MESSAGE_INVALID_COMMAND);
		}
		return true;
	}
	
	/*
	 * @param	taskList	currentTaskList as prepared previously
	 * @return				An ArrayList that contains only overdue items from taskList
	 */
	private ArrayList<Task> getOverdue(ArrayList<Task> taskList){
		ArrayList<Task> matchedTasks = new ArrayList<Task>();
		String todaysDate = dateTimeConfig.getTodaysDate();
		for (Task t : taskList) {
			String taskDate = t.getDate();
			if (taskDate != null && isOverdueTask(taskDate, todaysDate)) {
				matchedTasks.add(t);
			}
		}
		return matchedTasks;
	}
	
	/*
	 * @param	taskList	currentTaskList as prepared previously
	 * @return				An ArrayList that contains only memos from taskList
	 */
	private ArrayList<Task> getMemos(ArrayList<Task> taskList){
		ArrayList<Task> matchedTasks = new ArrayList<Task>();
		for (Task t : taskList) {
			if (isMemo(t)) {
				matchedTasks.add(t);
			}
		}
		return matchedTasks;
	}

	/*
	 * Generates an ArrayList of tasks that contains tasks based on completion status, 
	 * as specified by statusRequested
	 * 
	 * @param	taskList		currentTaskList as prepared previously
	 * @param	statusRequested	Is done (true) or not done (false)
	 * @return					An ArrayList that contains only items with matching status from taskList
	 */
	private ArrayList<Task> getTasksBasedOnCompletion(ArrayList<Task> taskList, 
			boolean statusRequested) {
		ArrayList<Task> matchedTasks = new ArrayList<Task>();

		for (Task t : taskList) {
			if (t.getIsDone() == statusRequested) {
				matchedTasks.add(t);
			}
		}
		return matchedTasks;
	}
	
	/*
	 * @return 	An ArrayList that contains tasks dated today
	 */
	public ArrayList<Task> getTodaysTasks(){
		ArrayList<Task> matchedTasks = new ArrayList<Task>();
		String todaysDate = dateTimeConfig.getTodaysDate();

		for (Task t : allTasks) {
			String taskDate = t.getDate();
			if (taskDate != null && dateTimeConfig.isPastOrToday(taskDate, todaysDate)) {
				matchedTasks.add(t);
			}
		}
		matchedTasks = getTasksBasedOnCompletion(matchedTasks, false);

		return matchedTasks;
	}
	
	/*
	 * @return	Feedback when there are tasks to be displayed
	 */
	private String getFeedbackIfHaveTasks(String displayType) {
		String feedback = "";
		if (displayType.equals(DONE)) {
			feedback = FEEDBACK_DISPLAY_DONE;
		} else if (displayType.equals(TODAY)) {
			feedback = FEEDBACK_DISPLAY_TODAY;
		} else if (displayType.equals(UNDONE)) {
			feedback = FEEDBACK_DISPLAY_UNDONE;
		}  else if (displayType.equals(ALL)) {
			feedback = FEEDBACK_DISPLAY_ALL;
		} else if (displayType.equals(MEMOS)) {
			feedback = FEEDBACK_DISPLAY_MEMOS;
		} else if (displayType.equals(OVERDUE)) {
			feedback = FEEDBACK_DISPLAY_OVERDUE;
		}
		
		return feedback;
	}
	
	/*
	 * @return	Feedback when there are no tasks to be displayed
	 */
	private String getFeedbackIfHaveNoTasks(String displayType) {
		String feedback = "";
		if (displayType.equals(OVERDUE)) {
			feedback = FEEDBACK_NO_OVERDUE;
		} else if (displayType.equals(MEMOS)) {
			feedback = FEEDBACK_NO_MEMOS;
		} else if (displayType.equals(DONE)) {
			feedback = FEEDBACK_NO_DONE;
		} else if (displayType.equals(TODAY)) {
			feedback = FEEDBACK_NO_TODAY;
		} else if (displayType.equals(UNDONE)) {
			feedback = FEEDBACK_NO_UNDONE;
		}  else if (displayType.equals(ALL)) {
			feedback = "You have no tasks.";
		}
		
		return feedback;
	}

	/*
	 * @return	Text to be display on screen
	 */
	protected String formDisplayText(Result result) {
		
		ArrayList<Task> uncompletedTasks = getTasksBasedOnCompletion(currentTaskList, false);
		ArrayList<Task> completedTasks = getTasksBasedOnCompletion(currentTaskList, true);
		
		String displayText = "";
		int numberOfUncompletedTasks = 0;
		if (!uncompletedTasks.isEmpty()) {
			displayText += formDisplayTextUncompletedTasks(uncompletedTasks, result);
			numberOfUncompletedTasks = uncompletedTasks.size();
		}
		if (!completedTasks.isEmpty()) {
			displayText += formDisplayTextCompletedTasks(completedTasks, numberOfUncompletedTasks, result);
		}
		
		return displayText;
	}

	/*
	 * Generates text to show on display screen and saves it using the Result class.
	 * 
	 * @param	taskList	List of tasks to generate display text from
	 * @param 	result		Stores display text in separate components (headings/task details)
	 * @return				String of text to display
	 */
	private String formDisplayTextUncompletedTasks(ArrayList<Task> taskList, Result result) {
		String displayText = "";
		String todaysDate = dateTimeConfig.getTodaysDate();

		boolean isPrintingOverdue = false;
		boolean isPrintingToday = false;
		boolean isPrintingWeek = false;
		boolean isPrintingAfterAWeek = false;
		boolean isPrintingMemos = false;

		int count = 1;
		
		for (Task t : taskList) {
			String taskDate = t.getDate();
			if (isMemo(t)) {
				if (!isPrintingMemos) {
					displayText += '\n' + HEADING_MEMO;
					isPrintingMemos = true;
					
					saveResultHeadings(result, HEADING_MEMO);
				}
			} else if (isOverdueTask(taskDate, todaysDate) && !isPrintingOverdue) {
				displayText += HEADING_OVERDUE;
				isPrintingOverdue = true;
				
				saveResultHeadings(result, HEADING_OVERDUE);
				
			} else if (isTodaysTask(taskDate, todaysDate) && !isPrintingToday) {
				displayText += '\n' + HEADING_TODAY;
				isPrintingToday = true;
				
				saveResultHeadings(result, HEADING_TODAY);
				
			} else if (isThisWeeksButNotTodaysTask(taskDate, todaysDate) && !isPrintingWeek) {
				displayText += '\n' + HEADING_THIS_WEEK;
				isPrintingWeek = true;
				
				saveResultHeadings(result, HEADING_THIS_WEEK);

			} else if (isAfterThisWeeksTask(taskDate, todaysDate) && !isPrintingAfterAWeek) {
				displayText += '\n' + HEADING_AFTER_A_WEEK;
				isPrintingAfterAWeek = true;
				
				saveResultHeadings(result, HEADING_AFTER_A_WEEK);
			}
			
			displayText += formDisplayTextOfOneTask(count, t);
			result.pushTaskToCurrentHeading(formDisplayTextOfOneTask(count, t));
			count++;
			
			if (t == taskToHighlight) {
				result.saveHighlightIndex();
			}
		}
		
		result.savePreviousHeading();
		return displayText;
	}
	
	/*
	 * Sub-method that generates text to show on display screen for completed tasks only. Completed tasks 
	 * either appear alone on the screen or are appended at the bottom of the list on screen.
	 * 
	 * @param	taskList			List of tasks to generate display text from
	 * @param	continueNumbering	0 = completed tasks appear alone, otherwise at the bottom of list
	 * @param 	result				Stores display text in separate components (headings/task details)
	 * @return						String of text to display
	 */
	private String formDisplayTextCompletedTasks(ArrayList<Task> taskList, int continueNumbering, Result result) {
		String displayText = "";
		
		if (continueNumbering == 0) {
			displayText += HEADING_COMPLETED;
			
			saveResultHeadings(result, HEADING_COMPLETED);
		} else {
			displayText += '\n' + HEADING_COMPLETED;
			
			saveResultHeadings(result, HEADING_COMPLETED);
		}
		
		for (int i = 0; i < taskList.size(); i++) {
			displayText += formDisplayTextOfOneTask((i+1)+continueNumbering, taskList.get(i));
			result.pushTaskToCurrentHeading(formDisplayTextOfOneTask((i+1)+continueNumbering, taskList.get(i)));
		}
		
		result.savePreviousHeading();
		return displayText;
	}
	
	private String formDisplayTextOfOneTask(int count, Task t) {
		return TASK_NUMBER_SPACING + count + ". " + t.getAllTaskDetails();
	}
	
	/*
	 * Called method in Result class that saves existing contents before starting a new heading.
	 * 
	 * @param 	result	Stores display text in separate components (headings/task details)
	 * @param	heading	New heading
	 */
	private void saveResultHeadings(Result result, String heading) {
		result.savePreviousHeading();
		result.pushNewHeadingText(heading);
	}
	
	/*
	 * Checks if a task t is a memo.
	 * 
	 * @param t		Task to be checked
	 */
	private boolean isMemo(Task t) {
		String taskType = t.getType();
		return (taskType.equals("noSetTiming")) ? true : false;
	}

	/*
	 * Checks if a task is overdue given the task's date and today's date.
	 * 
	 * @param	taskD 	Tasks's date
	 * @param	todaysD	Today's date
	 */
	private boolean isOverdueTask(String taskD, String todaysD) {
		String taskDate = dateTimeConfig.reverseDate(taskD);
		String todaysDate = dateTimeConfig.reverseDate(todaysD);
		return (taskDate.compareTo(todaysDate) < 0) ? true : false;
	}

	/*
	 * Checks if a task occurs on today given the task's date and today's date.
	 * 
	 * @param	taskD 	Tasks's date
	 * @param	todaysD	Today's date
	 */
	private boolean isTodaysTask(String taskDate, String todaysDate) {
		return (taskDate.equals(todaysDate)) ? true : false;
	}

	/*
	 * Checks if a task is within the week (up to 6 days from today), but also does not fall on today,
	 * given the task's date and today's date.
	 * 
	 * @param	taskD 	Tasks's date
	 * @param	todaysD	Today's date
	 */
	private boolean isThisWeeksButNotTodaysTask(String taskDate, String todaysDate) {
		return (dateTimeConfig.isThisWeekButNotToday(taskDate, todaysDate)) ? true : false;
	}

	/*
	 * Checks if a task occurs more than 7 days from today, given the task's date and today's date.
	 * 
	 * @param	taskD 	Tasks's date
	 * @param	todaysD	Today's date
	 */
	private boolean isAfterThisWeeksTask(String taskDate, String todaysDate) {
		return (dateTimeConfig.isAfterAWeek(taskDate, todaysDate)) ? true : false;
	}
	
	public void setTaskToHighlight(Task task) {
		taskToHighlight = task;
	}
}

	// End of segment: C:\Users\Sai Hou\Documents\SAIHOU\CS2103T\cs2103jan2014-w13-4j\src\DisplayCommand.java





	/**
	 * origin: C:\Users\Sai Hou\Documents\SAIHOU\CS2103T\cs2103jan2014-w13-4j\src\Result.java
	 */

	/*
	 * Compares two Result objects.
	 * 
	 * @see java.lang.Object#equals(java.lang.Object)
	 * @return True if both objects contain the same information, false otherwise.
	 */
	@Override
	public boolean equals(Object object) {
		if (!(object instanceof Result)) {
			return false;
		} else {
			Result r = (Result)object;
			boolean isEqual = true;
			
			System.out.println(highlightIndexI + " " +  r.getHighlightIndexI());
			if (highlightIndexI != r.getHighlightIndexI()) {
				isEqual = false;
			}
			
			System.out.println(highlightIndexJ + " " +  r.getHighlightIndexJ());
			if (highlightIndexJ != r.getHighlightIndexJ()) {
				isEqual = false;
			}
			
			System.out.println(systemFeedback);
			System.out.println(r.getSystemFeedback());
			if (!systemFeedback.equals(r.getSystemFeedback())) {
				isEqual = false;
			}
			
			System.out.println("Checking results headings");
			if (!Arrays.equals(headings.toArray(), r.getHeadings().toArray())) {
				isEqual = false;
			}
			
			System.out.println("Checking results body");
			if (body.size() != r.getBody().size()) {
				isEqual = false;
			}
			
			System.out.println(this.body);
			System.out.println(r.getBody());
			
			for (int i = 0 ; i < body.size() ; i++) {
				Queue<String> thisBodySegment = body.poll();
				Queue<String> otherBodySegment = r.getBody().poll();
				
				if (!Arrays.equals(thisBodySegment.toArray(), otherBodySegment.toArray())) {
					isEqual = false;
				}
			}
			
			System.out.println("Results are equal: " + isEqual);
			return isEqual;
		}
	}
	
	// End of segment: C:\Users\Sai Hou\Documents\SAIHOU\CS2103T\cs2103jan2014-w13-4j\src\Result.java





	/**
	 * origin: C:\Users\Sai Hou\Documents\SAIHOU\CS2103T\cs2103jan2014-w13-4j\src\Search.java
	 */

	protected ArrayList<Task> searchByDate(String date) {
		ArrayList<Task> matchedTasks = new ArrayList<Task>();

		for (Task t : searchList) {
			String taskDate = t.getDate();

			if (taskDate != null) {
				if (taskDate.equals(date)) {
					matchedTasks.add(t);
				}
			}
		}
		return matchedTasks;
	}
}

	// End of segment: C:\Users\Sai Hou\Documents\SAIHOU\CS2103T\cs2103jan2014-w13-4j\src\Search.java





	/**
	 * origin: C:\Users\Sai Hou\Documents\SAIHOU\CS2103T\cs2103jan2014-w13-4j\src\Task.java
	 */

	/*
	 * @param	haveDate	Specifies whether date should be printed
	 * @return	Returns a String that contains all task details in order for display Command :
	 * 			Task name which all tasks must have, followed by date if required then time 
	 * 			and then optional details.
	 */
	private String getTaskDetails(boolean haveDate) {
		String taskDetails = this.name + '\n';
		
		assert taskDetails != null;
		
		if (haveDate && !this.type.equals(TASK_TYPE_NO_SET_TIMING)) {
			taskDetails += SPACING + dateTimeConfig.getDateForDisplay(this.date) + '\n';
		}
		if (this.type.equals("setDuration")) {
			taskDetails += SPACING + "From " + dateTimeConfig.getTimeForDisplay(this.startTime) +
							" to " + dateTimeConfig.getTimeForDisplay(this.endTime) + '\n';
		} else if (this.type.equals("targetedTime")){
			taskDetails += SPACING + "At/By " + 
							dateTimeConfig.getTimeForDisplay(this.startTime) + '\n';
		}
		if (getLocation() != null) {
			taskDetails += SPACING + this.location + '\n';
		}
		return taskDetails;
	}
	
	public String getTaskDetailsWithoutDate() {
		return getTaskDetails(false);
	}
	
	public String getAllTaskDetails(){
		return getTaskDetails(true);
	}

	/*
	 * This function allows Collections objects that store Task to sort it according to these rules:
	 *  
	 * 1. Tasks with timing sorted by date. Under each date:
	 * 		1.1 Full day tasks should appear at the top under each date
	 * 		1.2 Tasks with timings should follow chronologically 
	 * 2. Tasks with no set timing appear at the bottom of entire displayed list alphabetically
	 *
	 * @see java.lang.Comparable#compareTo(java.lang.Object)
	 */
	@Override
	public int compareTo(Task t) {
		// Compare tasks with date/timing vs tasks with no set timing
		String taskType = t.getType();
		
		if (this.type.equals(TASK_TYPE_NO_SET_TIMING) && taskType.equals(TASK_TYPE_NO_SET_TIMING)) {
			// If both are noSetTiming Tasks, list alphabetically by name
			return compareAlphabetically(t);
		} else if (this.type.equals(TASK_TYPE_NO_SET_TIMING)){
			// else if either is noSetTiming task, return that task is larger
			return 1;
		} else if (taskType.equals(TASK_TYPE_NO_SET_TIMING)) {
			return -1;
		} else {
			// both not noSetTiming tasks i.e. both have dates, then compare by date
			return compareByDate(t, taskType);
		}
	}

	private int compareByDate(Task t, String taskType) {
		// Compare by date and within each, compare by type again
		String thisDate = dateTimeConfig.reverseDate(this.date);
		String tDate = dateTimeConfig.reverseDate(t.getDate());
		
		if (thisDate.equals(tDate)) {
			// They have the same date, so compare type
			return compareType(t, taskType);
		} else {
			return thisDate.compareTo(tDate);
		}
	}

	private int compareType(Task t, String taskType) {
		if (this.type.compareTo(TASK_TYPE_FULL_DAY) == 0) {
			return -1;
		} else if (taskType.compareTo(TASK_TYPE_FULL_DAY) == 0) {
			return 1;
		} else {
			//both not fullDay tasks, so compare time
			return compareTime(t);
		}
	}

	private int compareTime(Task t) {
		String thisTime = this.startTime;
		String tTime = t.getStartTime();
		return thisTime.compareTo(tTime);
	}

	private int compareAlphabetically(Task t) {
		String tName = t.getName();
		return this.name.compareTo(tName);
	}
	
	private String capitalizeString(String name) {
		return (Character.toUpperCase(name.charAt(0)) + name.substring(1));
	}
	
	// End of segment: C:\Users\Sai Hou\Documents\SAIHOU\CS2103T\cs2103jan2014-w13-4j\src\Task.java





